"""
Realistic Mock Odoo Service with 1500+ Patients

This provides the same interface as the real Odoo client but with realistic mock data.
Loads data from JSON files generated by generate_mock_data.py
"""

import json
import os
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from pathlib import Path


class RealisticMockOdooClient:
    """Mock Odoo client with realistic data from JSON files."""
    
    def __init__(self):
        """Initialize mock client and load data from JSON files."""
        self.data_dir = Path(__file__).parent.parent.parent / "data"
        
        # Load data from JSON files
        self.patients = self._load_json("mock_patients.json")
        self.appointments = self._load_json("mock_appointments.json")
        self.invoices = self._load_json("mock_invoices.json")
        self.treatment_records = self._load_json("mock_treatment_records.json")
        
        # Create indexes for faster lookups
        self._create_indexes()
        
        print(f"✅ Loaded realistic mock data:")
        print(f"   - {len(self.patients)} patients")
        print(f"   - {len(self.appointments)} appointments")
        print(f"   - {len(self.invoices)} invoices")
        print(f"   - {len(self.treatment_records)} treatment records")
    
    def _load_json(self, filename: str) -> List[Dict[str, Any]]:
        """Load data from JSON file."""
        filepath = self.data_dir / filename
        if not filepath.exists():
            print(f"⚠️  Warning: {filename} not found, using empty data")
            return []
        
        with open(filepath, 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def _create_indexes(self):
        """Create indexes for faster lookups."""
        # Patient index by ID
        self.patients_by_id = {p["id"]: p for p in self.patients}
        
        # Appointments by patient ID
        self.appointments_by_patient = {}
        for appt in self.appointments:
            patient_id = appt["patient_id"]
            if patient_id not in self.appointments_by_patient:
                self.appointments_by_patient[patient_id] = []
            self.appointments_by_patient[patient_id].append(appt)
        
        # Appointments by ID
        self.appointments_by_id = {a["id"]: a for a in self.appointments}
        
        # Invoices by patient ID
        self.invoices_by_patient = {}
        for inv in self.invoices:
            patient_id = inv["patient_id"]
            if patient_id not in self.invoices_by_patient:
                self.invoices_by_patient[patient_id] = []
            self.invoices_by_patient[patient_id].append(inv)
        
        # Invoices by ID
        self.invoices_by_id = {i["id"]: i for i in self.invoices}
        
        # Treatment records by patient ID
        self.records_by_patient = {}
        for record in self.treatment_records:
            patient_id = record["patient_id"]
            if patient_id not in self.records_by_patient:
                self.records_by_patient[patient_id] = []
            self.records_by_patient[patient_id].append(record)
    
    def authenticate(self) -> bool:
        """Mock authentication - always succeeds."""
        return True
    
    # Patient Management
    
    def search_patients(self, name: Optional[str] = None, phone: Optional[str] = None) -> List[int]:
        """Search for patients by name or phone."""
        results = []
        
        for patient in self.patients:
            if name and name.lower() in patient["name"].lower():
                results.append(patient["id"])
            elif phone and phone in patient["phone"]:
                results.append(patient["id"])
        
        return results
    
    def get_patient(self, patient_id: int) -> Optional[Dict[str, Any]]:
        """Get patient details by ID."""
        return self.patients_by_id.get(patient_id)
    
    def create_patient(self, name: str, email: Optional[str] = None, 
                      phone: Optional[str] = None) -> int:
        """Create a new patient."""
        patient_id = len(self.patients) + 1
        patient = {
            "id": patient_id,
            "name": name,
            "email": email,
            "phone": phone,
            "birth_date": None,
            "registration_date": datetime.now().strftime("%Y-%m-%d"),
            "address": None,
            "insurance_provider": None,
            "insurance_number": None,
            "emergency_contact": None,
            "allergies": "None",
            "medical_conditions": "None",
            "last_visit": None,
            "total_visits": 0,
            "outstanding_balance": 0,
        }
        self.patients.append(patient)
        self.patients_by_id[patient_id] = patient
        return patient_id
    
    # Appointment Management
    
    def search_appointments(
        self,
        patient_id: Optional[int] = None,
        date_from: Optional[str] = None,
        date_to: Optional[str] = None,
        status: Optional[str] = None,
    ) -> List[int]:
        """Search for appointments."""
        if patient_id:
            appointments = self.appointments_by_patient.get(patient_id, [])
        else:
            appointments = self.appointments
        
        results = []
        for appt in appointments:
            # Filter by date range
            if date_from and appt["date"] < date_from:
                continue
            if date_to and appt["date"] > date_to:
                continue
            
            # Filter by status
            if status and appt["status"] != status:
                continue
            
            results.append(appt["id"])
        
        return results
    
    def get_appointment(self, appointment_id: int) -> Optional[Dict[str, Any]]:
        """Get appointment details by ID."""
        return self.appointments_by_id.get(appointment_id)
    
    def create_appointment(
        self,
        patient_id: int,
        date: str,
        time: str,
        treatment_type: str,
        duration_minutes: int = 60,
    ) -> int:
        """Create a new appointment."""
        appointment_id = len(self.appointments) + 1
        patient = self.patients_by_id.get(patient_id)
        
        appointment = {
            "id": appointment_id,
            "patient_id": patient_id,
            "patient_name": patient["name"] if patient else "Unknown",
            "date": date,
            "time": time,
            "datetime": f"{date}T{time}:00",
            "treatment_type": treatment_type,
            "duration_minutes": duration_minutes,
            "dentist": "Dr. Smith",
            "status": "scheduled",
            "notes": "",
            "created_at": datetime.now().isoformat(),
        }
        
        self.appointments.append(appointment)
        self.appointments_by_id[appointment_id] = appointment
        
        if patient_id not in self.appointments_by_patient:
            self.appointments_by_patient[patient_id] = []
        self.appointments_by_patient[patient_id].append(appointment)
        
        return appointment_id
    
    def cancel_appointment(self, appointment_id: int) -> bool:
        """Cancel an appointment."""
        appointment = self.appointments_by_id.get(appointment_id)
        if appointment:
            appointment["status"] = "cancelled"
            return True
        return False
    
    def get_available_slots(
        self,
        date_from: str,
        date_to: str,
    ) -> List[Dict[str, Any]]:
        """Get available appointment slots."""
        # Generate available slots (simplified)
        slots = []
        current_date = datetime.strptime(date_from, "%Y-%m-%d")
        end_date = datetime.strptime(date_to, "%Y-%m-%d")
        
        while current_date <= end_date:
            # Skip weekends
            if current_date.weekday() < 5:  # Monday-Friday
                # Generate slots from 8 AM to 6 PM
                for hour in range(8, 18):
                    for minute in [0, 30]:
                        slot_time = current_date.replace(hour=hour, minute=minute)
                        
                        # Check if slot is already booked
                        is_booked = any(
                            appt["datetime"] == slot_time.isoformat()
                            for appt in self.appointments
                            if appt["status"] == "scheduled"
                        )
                        
                        if not is_booked:
                            slots.append({
                                "date": current_date.strftime("%Y-%m-%d"),
                                "time": slot_time.strftime("%H:%M"),
                                "datetime": slot_time.isoformat(),
                                "available": True,
                            })
            
            current_date += timedelta(days=1)
        
        return slots[:50]  # Return first 50 available slots
    
    # Invoice Management
    
    def search_invoices(
        self,
        patient_id: Optional[int] = None,
        status: Optional[str] = None,
    ) -> List[int]:
        """Search for invoices."""
        if patient_id:
            invoices = self.invoices_by_patient.get(patient_id, [])
        else:
            invoices = self.invoices
        
        results = []
        for inv in invoices:
            if status and inv["status"] != status:
                continue
            results.append(inv["id"])
        
        return results
    
    def get_invoice(self, invoice_id: int) -> Optional[Dict[str, Any]]:
        """Get invoice details by ID."""
        return self.invoices_by_id.get(invoice_id)
    
    def create_invoice(
        self,
        patient_id: int,
        appointment_id: int,
        treatment: str,
        amount: float,
    ) -> int:
        """Create a new invoice."""
        invoice_id = len(self.invoices) + 1
        patient = self.patients_by_id.get(patient_id)
        
        issue_date = datetime.now()
        due_date = issue_date + timedelta(days=30)
        
        invoice = {
            "id": invoice_id,
            "patient_id": patient_id,
            "patient_name": patient["name"] if patient else "Unknown",
            "appointment_id": appointment_id,
            "issue_date": issue_date.strftime("%Y-%m-%d"),
            "due_date": due_date.strftime("%Y-%m-%d"),
            "treatment": treatment,
            "total_amount": amount,
            "insurance_amount": 0,
            "patient_amount": amount,
            "paid_amount": 0,
            "outstanding_amount": amount,
            "status": "unpaid",
            "payment_method": None,
            "invoice_number": f"INV-{issue_date.year}-{invoice_id:05d}",
        }
        
        self.invoices.append(invoice)
        self.invoices_by_id[invoice_id] = invoice
        
        if patient_id not in self.invoices_by_patient:
            self.invoices_by_patient[patient_id] = []
        self.invoices_by_patient[patient_id].append(invoice)
        
        return invoice_id
    
    # Treatment Records
    
    def get_treatment_history(self, patient_id: int) -> List[Dict[str, Any]]:
        """Get treatment history for a patient."""
        return self.records_by_patient.get(patient_id, [])
    
    # Statistics
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get clinic statistics."""
        total_revenue = sum(inv["total_amount"] for inv in self.invoices)
        outstanding_balance = sum(inv["outstanding_amount"] for inv in self.invoices)
        
        return {
            "total_patients": len(self.patients),
            "total_appointments": len(self.appointments),
            "completed_appointments": len([a for a in self.appointments if a["status"] == "completed"]),
            "scheduled_appointments": len([a for a in self.appointments if a["status"] == "scheduled"]),
            "total_revenue": total_revenue,
            "outstanding_balance": outstanding_balance,
            "total_invoices": len(self.invoices),
            "paid_invoices": len([i for i in self.invoices if i["status"] == "paid"]),
            "unpaid_invoices": len([i for i in self.invoices if i["status"] == "unpaid"]),
        }


# Create singleton instance
realistic_mock_odoo = RealisticMockOdooClient()
